import 'lib/list'
import 'lib/hash'

[1, 5, 3, 9, 2] -> list/max -> (<9> 'Pass' ! <> 'Fail: max is $; should be 9' !) -> !OUT::write

[] -> list/max -> 'Fail: max should not output $;' -> !OUT::write

[1, 5, 3, 9, 2] -> list/min -> (<1> 'Pass' ! <> 'Fail: min is $; should be 1' !) -> !OUT::write

[] -> list/min -> 'Fail: min should not output $;' -> !OUT::write

[1, 5, 3, 9, 2] -> list/sum -> (<20> 'Pass' ! <> 'Fail: sum is $; should be 20' !) -> !OUT::write

[] -> [ $ ->list/sum ] -> (<[<0>](1)> 'Pass' ! <> 'Fail: sum of empty list should be 0' !) -> !OUT::write

templates onA
  <?($(1).a <..~$(2).a>)> -1 !
  <?($(1).a <$(2).a>)> 0 !
  <> 1 !
end onA

def expectedSorted: [{a: 1, b: 'l'}, {a: 2, b: 'n'}, {a: 3, b: 'k'}, {a: 6, b: 'j'}, {a: 9, b: 'm'}];

[{a: 6, b: 'j'}, {a: 3, b: 'k'}, {a: 1, b: 'l'}, {a: 9, b: 'm'}, {a: 2, b: 'n'}] -> list/sort@{comparator: onA}
-> (<$expectedSorted> 'Pass' ! <> 'Fail, not sorted $;' !) -> !OUT::write

[4, 3, 1, 5, 2, 7, 9, 8, 8, 5, 3] -> list/sort@{comparator:list/naturalOrder} -> (
  @:$(1);
  [ $(2..-1)... -> # ] -> (<[](0)> 'Pass' ! <> 'Fail$;' !) !
  <$@..> @: $;
  <> ':$@; before $;' !
) -> !OUT::write

def set: [1, 1, 2, 5, 2, 2, 5, 1] -> hash/Set;

[ $set::values ] -> (<[<1>,<2>,<5>](3)> 'Pass' ! <> 'Fail $;' !) -> !OUT::write

1 -> set::add -> (<0> 'Pass' ! <> 'Fail: set should contain 1' !) -> !OUT::write

4 -> set::add -> (<1> 'Pass' ! <> 'Fail: set should not contain 4' !) -> !OUT::write

4 -> set::add -> (<0> 'Pass' ! <> 'Fail: set should now contain 4' !) -> !OUT::write

5 -> set::remove -> (<1> 'Pass' ! <> 'Fail: set should remove 5' !) -> !OUT::write

5 -> set::remove -> (<0> 'Pass' ! <> 'Fail: set should not remove 5 again' !) -> !OUT::write

4 -> set::contains -> (<1> 'Pass' ! <> 'Fail: set should contain 4' !) -> !OUT::write

5 -> set::contains -> (<0> 'Pass' ! <> 'Fail: set should not contain 5' !) -> !OUT::write

def map: [{key: 'a', value: 1}, {key: 'b', value: 2}] -> hash/Map;

[ $map::entries ] -> (<[<{key: <'a'>, value: <1>}>]> $ ! <> 'Fail $;' !) -> (<[<{key: <'b'>, value: <2>}>]> $ ! <> 'Fail $;' !)
  ->  (<[](2)> 'Pass' ! <> 'Fail $;' !) -> !OUT::write

'a' -> map::get -> (<1> 'Pass' ! <> 'Fail: a should be mapped to 1' !) -> !OUT::write

[{key: 'a', value: 33} -> map::put] -> (<[<1>](1)> 'Pass' ! <> 'Fail: should evict 1 for a but was $;' !)
  -> !OUT::write

'a' -> map::get -> (<33> 'Pass' ! <> 'Fail: a should now be mapped to 33' !) -> !OUT::write

['c' -> map::get] -> (<[](0)> 'Pass' ! <> 'Fail: c should not be mapped' !) -> !OUT::write

['b' -> map::remove] -> (<[<2>](1)> 'Pass' ! <> 'Fail: should remove 2 for b but was $;' !)
  -> !OUT::write

['b' -> map::get] -> (<[](0)> 'Pass' ! <> 'Fail: b should not be mapped' !) -> !OUT::write

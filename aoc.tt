package aoc

composer parseIntcode
  [ <code>+ ]
  rule code: <INT> (<','>?)
end parseIntcode

templates compute@{inputs:}
  def machine: $ -> MarkII;
  $inputs -> machine::proceed -> #
  <{ result: <> }> $.result !
  <{ out: <0> }> !VOID // ignore passing diagnostic test
  <> $ !
end compute

processor MarkII
  @: { memory: $, position: 1, input:[] };

  templates opcode
    $@MarkII.memory($) mod 100 !
  end opcode
  templates params@{n:}
    templates modes
      @: $ ~/ 100;
      [ 1..$n -> ( $@modes mod 10 ! @modes: $@modes ~/ 10;) ] !
    end modes
    def base: $;
    $@MarkII.memory($) -> modes -> \[i](def val: $@MarkII.memory($base + $i);
      $ -> #
      <=0> $@MarkII.memory($val + 1) !
      <=1> $val !
    \) !
  end params

    templates proceed
      $ -> \(<[]> $... ! <> $ !\) -> ..|@MarkII.input: $;
      $@MarkII.position -> #

      <?($ -> opcode <=99>)>
        @MarkII.position: 0;
        { result: $@MarkII.memory(1) } !

      <?($ -> opcode <=1>)>
        def params: $ -> params@{n: 2};
        def result: $@MarkII.memory($ + 3) + 1;
        @MarkII.memory($result): $params(1) + $params(2);
        $ + 4 -> #

      <?($ -> opcode <=2>)>
        def params: $ -> params@{n: 2};
        def result: $@MarkII.memory($ + 3) + 1;
        @MarkII.memory($result): $params(1) * $params(2);
        $ + 4 -> #

      <?($ -> opcode <=3>)?($@MarkII.input <[](0)>)>
        // Park it and wait for input
        @MarkII.position: $;

      <?($ -> opcode <=3>)>
        def result: $@MarkII.memory($ + 1) + 1;
        @MarkII.memory($result): ^@MarkII.input(1);
        $ + 2 -> #

      <?($ -> opcode <=4>)?($ + 2 -> opcode <=99>)>
        @MarkII.position: 0;
        $ -> params@{n: 1} -> { result: $(1) } !

      <?($ -> opcode <=4>)>
        { position: $, out: $ -> params@{n: 1}... } !
        $ + 2 -> #

      <?($ -> opcode <=5>)>
        def params: $ -> params@{n: 2};
        $ + 3 -> \(<?($params(1) <~=0>)> $params(2) + 1 ! <> $ ! \) -> #

      <?($ -> opcode <=6>)>
        def params: $ -> params@{n: 2};
        $ + 3 -> \(<?($params(1) <=0>)> $params(2) + 1 ! <> $ ! \) -> #

      <?($ -> opcode <=7>)>
        def params: $ -> params@{n: 2};
        def result: $@MarkII.memory($ + 3) + 1;
        @MarkII.memory($result): $params(1) -> \(<..~$params(2)> 1 ! <> 0 !\);
        $ + 4 -> #

      <?($ -> opcode <=8>)>
        def params: $ -> params@{n: 2};
        def result: $@MarkII.memory($ + 3) + 1;
        @MarkII.memory($result): $params(1) -> \(<=$params(2)> 1 ! <> 0 !\);
        $ + 4 -> #

      <> 'Error! $; $ -> params@{n: 1}; $@MarkII.memory($-10..$+1);' !
    end proceed
end MarkII
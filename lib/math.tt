package math

templates abs
  <0..> $ !
  <..0> -$ !
end abs

templates sign
  <=0> 0 !
  <0..> 1 !
  <..0> -1 !
end sign

templates manhattanDistance
  @: 0;
  $ -> #
  $@ !
  <[]> $... -> #
  <{}> $... -> $::value -> #
  <0..> @: $@ + $;
  <..0> @: $@ - $;
end manhattanDistance

templates gcd
  <{a: <=0>}> $.b -> abs !
  <{b: <=0>}> $.a -> abs !
  <{a: <..~0>}|{b: <..~0>}> { a: $.a -> abs, b: $.b -> abs } -> #
  <{a:<=1>}|{b:<=1>}> 1 !
  <{a:<..$.b>, b:<>}> { a: $.a, b: $.b mod $.a } -> #
  <{a:<>, b:<>}> { a: $.b, b: $.a mod $.b } -> #
end gcd

templates extendedGcd
  <{a: <=0>}> { x: 0, y: 1, gcd: $.b } !
  <> def q: $.b ~/ $.a;
    { a: $.b - $q * $.a, b: $.a } -> extendedGcd -> { x: $.y - $q * $.x, y: $.x, gcd: $.gcd } !
end extendedGcd

templates mulMod@{mod:}
  @: { result: 0, b: $(1) mod $mod };
  $(2) mod $mod -> #
  <=0> $@.result !
  <>
    $ -> \(<?($ mod 2 <=1>)> @mulMod.result: ($@mulMod.result + $@mulMod.b) mod $mod;\) -> !VOID
    @.b: $@.b * 2 mod $mod;
    $ ~/ 2 -> #
end mulMod

templates powerMod@{mod:}
  @: { result: 1, b: $(1) };
  $(2) mod ($mod - 1) -> #
  <=0> $@.result !
  <>
    $ -> \(<?($ mod 2 <=1>)> @powerMod.result: [$@powerMod.result, $@powerMod.b] -> mulMod@{mod:$mod};\) -> !VOID
    @.b: [$@.b, $@.b] -> mulMod@{mod:$mod};
    $ ~/ 2 -> #
end powerMod

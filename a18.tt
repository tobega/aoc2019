import 'lib/hash'
import 'lib/list'

def map: [ $IN::lines -> [ $... ]];

def start: $map -> \[i,j](<='@'> { row: $i, col: $j } !\) ... ...;

def keyPositions: [ $map -> \[i,j](<'\p{Lower}'> { key: $, row: $i, col: $j } !\) ... ...];

def keys: [ $keyPositions... ->  $.key ];

def doors: [ $map -> \[i,j](<'\p{Upper}'> $ !\) ... ...];

templates calculateDistances
  def directions: [ { dRow: 0, dCol: -1}, { dRow: 0, dCol: 1}, { dRow: -1, dCol: 0}, { dRow: 1, dCol: 0}];
  @: { map: $map, next: [], current: [{at: $start, distance: 0, doors: []}], found: [] -> hash/Map};
  1 -> #
  $@.found !

  <?($@.current <[](1..)>)>
    def base: ^@.current(1);
    $directions...
      -> { at: { row: $base.at.row + $.dRow, col: $base.at.col + $.dCol},
           distance: $base.distance + 1, doors: $base.doors}
      -> \checkMap(def onMap: $@calculateDistances.map($.at.row; $.at.col);
         $ -> #
         <?($onMap <='#'>)> !VOID
         <?($doors <[<$onMap>]>)> { $..., doors: [$.doors..., $onMap] } !
         <?($keys <[<$onMap>]>)>
           // accounting for different paths through different doors
           { key: { key: $onMap, doors: $.doors}, value: $.distance}
           // re-putting the first (shortest) path, if one exists
           -> @calculateDistances.found::put -> @calculateDistances.found::put -> !VOID
         <> $!
      \checkMap)
      -> \( @calculateDistances.map($.at.row; $.at.col): '#';
            ..|@calculateDistances.next: $; \) -> !VOID
    1 -> #
  <?($@.next <[](1..)>)>
    @.current: $@.next;
    @.next: [];
    1 -> #
end calculateDistances

processor DistanceTable
  @: [] -> hash/Map;

  sink add@{from:}
    def entry: { key: { from: $from, to : $.key.key}, value: [{ doors: $.key.doors, distance: $.value}]};
    $entry -> @::put -> { key: $entry.key, value: [$.value..., $entry.value...]} -> @::put -> !VOID
  end add

  templates pathLength
    def path: $;
    @: {at: '@', length: 0};
    1..$path::length -> #
    $@.length !

    <> def i: $;
      def stage: {from: $@.at, to: $path($i)} -> @DistanceTable::get;
      @.length: $@.length + $stage.distance;
      $stage.doors... -> \(<?($path(1..$i) <~[<'(?i)$;'>]>)>
        @pathLength.distance: $@pathLength.distance + 100; \) -> !VOID
      @.at: $path($i);
  end pathLength
end DistanceTable

def distanceTable: $DistanceTable;

$start -> calculateDistances -> $::entries -> !distanceTable::add@{from: '@'}
$keyPositions... -> \( def from: $.key;
  $ -> calculateDistances -> $::entries -> !distanceTable::add@{from: $from}
\) -> !VOID

source geneSoup@{popSize:, genes:}
  source generateHalfChromosome
    @: $genes;
    [ 1..$genes::length -> $@::length -> SYS::randomInt -> ^@($+1) ] !
  end generateHalfChromosome

  source createCell
    { age: 0, chromosome: $, value: [ $... -> distanceTable::pathLength ] -> list/min} !
  end createCell

  templates getGamete
    def crossover: $genes::length + 1 -> SYS::randomInt;
    @: $.chromosome(1; 1..$crossover);
    $.chromosome(2)... -> \(<?($@getGamete <~[<$>]>)> ..|@getGamete: $;\) -> !VOID
    $@ !
  end getGamete

  templates mate
    @: { adults: $, babies: []};
    1 -> #
    $@.babies!

    <?($@.adults <[](2..)>)>
      [ 1..2 ->
        $@.adults::length -> SYS::randomInt -> ^@.adults($+1) -> getGamete ]
      -> createCell -> ..|@.babies: $;
      1 -> #
  end mate

  sink updateBest
    <..~$@geneSoup.best> @geneSoup.best: $;
  end updateBest

  source isStagnated
    @: 0;
    [1..3 -> $popSize -> SYS::randomInt -> $@geneSoup.pop($+1) ] -> #
    $@!
    
    // check if all equal, actually it is not an array containing anything different from the first element
    <~[<~$(1)>]> @: 1;
      'Stagnated at $(1);$#10;' -> !OUT::write
  end isStagnated

  templates ageAndMutate
    @: $;
    @.age: $@.age+1;
    8 -> $SYS::randomInt -> #

    <..$@.age> !VOID // died
    <>
      100 -> $SYS::randomInt -> \(<=0> $!\)
      -> { rotate: $@::length -> $SYS::randomInt -> $+1, which: 2 -> $SYS::randomInt -> $+1}
      -> @.chromosome($.which): $@.cromosome($.which; [$rotate..-1, 1..$rotate-1]);
      100 -> $SYS::randomInt -> \(<=0> $!\)
      -> { displace: $@::length -> $SYS::randomInt -> $+1, which: 2 -> $SYS::randomInt -> $+1}
      -> @.chromosome($.which): $@.cromosome($.which; [$displace, 1..$displace-1, $displace+1..-1]);
      $@!
  end ageAndMutate

  sink enterPop
    {tries: 5, candidate: $} -> #
    <?($@geneSoup.pop::length <..~$popSize>)> ..|@geneSoup.pop: $.candidate;
    <{tries: <1..>}> def toReplace: $@geneSoup.pop::length -> $SYS::randomInt -> $+1;
      $ -> \(<{cell:<{value: <..$@geneSoup.pop($toReplace)>}>}> ..|@geneSoup.pop: $.candidate;
        <> { tries: $.tries-1, candidate: $.candidate} ! \) -> #
  end enterPop

  @: {best: 99999999999,
    pop: [ 1..$popSize~/4 -> [ $generateHalfChromosome, $generateHalfChromosome ] -> createCell ]};
  0 -> #
  $@.best !

  <=1> $@.best !
  <>
    def babies: $@.pop -> mate;
    $babies... -> $.value -> !updateBest
    @.pop: [$@.pop... -> ageAndMutate];
    $babies... -> !enterPop
    $isStagnated -> #
end geneSoup

// part 1
'The best path is $geneSoup;
' -> !OUT::write

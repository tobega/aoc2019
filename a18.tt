import 'lib/hash'
import 'lib/list'

def map: [ $IN::lines -> [ $... ]];

def start: $map -> \[i,j](<='@'> { row: $i, col: $j } !\) ... ...;

def keyPositions: [ $map -> \[i,j](<'\p{Lower}'> { key: $, row: $i, col: $j } !\) ... ...];

def keys: [ $keyPositions... ->  $.key ];

def doors: [ $map -> \[i,j](<'\p{Upper}'> $ !\) ... ...];

templates calculateDistances
  def directions: [ { dRow: 0, dCol: -1}, { dRow: 0, dCol: 1}, { dRow: -1, dCol: 0}, { dRow: 1, dCol: 0}];
  @: { map: $map, next: [], current: [{at: $, distance: 0, doors: [], others: []}], found: [] -> hash/Map};
  @.map($.row;$.col): '#';
  1 -> #
  $@.found !

  <?($@.current <[](1..)>)>
    def base: ^@.current(1);
    $directions...
      -> { at: { row: $base.at.row + $.dRow, col: $base.at.col + $.dCol},
           distance: $base.distance + 1, doors: $base.doors,
           others: $base.others}
      -> \isValid(
         <?($@calculateDistances.map($.at.row; $.at.col) <~='#'>)>
           $! \isValid)
      -> \checkDoor( def onMap: $@calculateDistances.map($.at.row; $.at.col);
         $ -> #
         <?($doors <[<$onMap>]>)> { $..., doors: [$.doors..., $onMap] } !
         <?($keys <[<$onMap>]>)> { $..., others: [$.others..., $onMap] } !
         <> $!
      \checkDoor)
      -> \propagate(
          ..|@calculateDistances.next: $;
          $ ! \propagate)
      -> \update( def onMap: $@calculateDistances.map($.at.row; $.at.col);
        $ -> #
        <?($keys <[<$onMap>]>)>
          // accounting for different paths through different doors
          { key: { key: $onMap, doors: $.doors, others: $.others}, value: $.distance}
          // re-putting the first (shortest) path, if one exists
          -> @calculateDistances.found::put -> @calculateDistances.found::put -> !VOID
        <>
          @calculateDistances.map($.at.row; $.at.col): '#';
        \update)
      -> !VOID
    1 -> #
  <?($@.next <[](1..)>)>
    @.current: $@.next;
    @.next: [];
    1 -> #
end calculateDistances

processor DistanceTable
  @: [] -> hash/Map;

  sink add@{from:}
    def entry: { key: { from: $from, to : $.key.key}, value: [{ others: $.key.others, doors: $.key.doors, distance: $.value}]};
    $entry -> @DistanceTable::put -> { key: $entry.key, value: [$.value..., $entry.value...]} -> @DistanceTable::put -> !VOID
  end add

  templates pathLength
    def path: $;
    @: {at: '@', length: 0};
    1..$path::length -> #
    $@.length !

    <> def i: $;
      {from: $@.at, to: $path($i)} -> @DistanceTable::get
      -> [ $... -> \distance( @: $.distance;
        $.doors... -> \(<?($path(1..$i) <~[<'(?i)$;'>]>)>
           @distance: $@distance + 1000; \) -> !VOID
        $.others... -> \(<?($path(1..$i) <~[<'(?i)$;'>]>)>
           @distance: $@distance + 1000; \) -> !VOID
        $@! \distance) ] -> list/min
      -> @.length: $@.length + $;
      @.at: $path($i);
  end pathLength

  source entries
    $@DistanceTable::entries!
  end entries
end DistanceTable

def distanceTable: $DistanceTable;

$start -> calculateDistances -> $::entries -> !distanceTable::add@{from: '@'}
$keyPositions... -> \( def from: $.key;
  $ -> calculateDistances -> $::entries -> !distanceTable::add@{from: $from}
\) -> !VOID

source geneSoup@{popSize:, genes:}
  source generateHalfChromosome
    @: $genes;
    [ 1..$genes::length -> \($@generateHalfChromosome::length -> SYS::randomInt -> ^@generateHalfChromosome($+1) !\) ] !
  end generateHalfChromosome

  source createCell
    { age: 0, chromosome: $, value: [ $... -> distanceTable::pathLength ] -> list/min} !
  end createCell

  templates getGamete
    def which: 2 -> SYS::randomInt;
    def crossover: $genes::length + 1 -> SYS::randomInt;
    @: $.chromosome(1 + $which; 1..$crossover);
    $.chromosome(2 - $which)... -> \(<?($@getGamete <~[<$>]>)> ..|@getGamete: $;\) -> !VOID
    $@ !
  end getGamete

  templates mate
    @: { adults: $, babies: []};
    1 -> #
    $@.babies!

    <?($@.adults <[](2..)>)>
      [ 1..2 ->
        \($@mate.adults::length -> SYS::randomInt -> ^@mate.adults($+1) -> getGamete ! \)]
      -> createCell -> ..|@.babies: $;
      1 -> #
  end mate

  sink updateBest
    <..~$@geneSoup.best> @geneSoup.best: $;
  end updateBest

  source isStagnated
    @: 0;
    [1..3 -> $@geneSoup.pop::length -> SYS::randomInt -> $@geneSoup.pop($+1).value ] -> #
    $@!
    
    // check if all equal, actually it is not an array containing anything different than best
    <~[<~$@geneSoup.best>]> @: 1;
      'Stagnated at $(1);$#10;' -> !OUT::write
  end isStagnated

  templates ageAndMutate
    @: $;
    @.age: $@.age+1;
    15 -> SYS::randomInt -> #

    <..$@.age> !VOID // died
    <>
      1..2 -> 100 -> SYS::randomInt -> \(<=0> $!\)
      -> { rotate: $genes::length -> SYS::randomInt -> $+1, which: 2 -> SYS::randomInt -> $+1}
      -> @.chromosome($.which): $@.chromosome($.which; [$.rotate..-1, 1..$.rotate-1]);
      1..5 -> 100 -> SYS::randomInt -> \(<=0> $!\)
      -> { displace: $genes::length -> SYS::randomInt -> $+1, which: 2 -> SYS::randomInt -> $+1}
      -> @.chromosome($.which): $@.chromosome($.which; [1..$.displace-1, $.displace+1..$.displace+1, $.displace, $.displace+2..-1]);
      $@!
  end ageAndMutate

  sink enterPop
    {tries: 5, candidate: $} -> #
    <?($@geneSoup.pop::length <..~$popSize>)> ..|@geneSoup.pop: $.candidate;
    <{tries: <1..>}> def toReplace: $@geneSoup.pop::length -> SYS::randomInt -> $+1;
      $ -> \(<{candidate:<{value: <..$@geneSoup.pop($toReplace).value>}>}> @geneSoup.pop($toReplace): $.candidate;
        <> { tries: $.tries-1, candidate: $.candidate} ! \) -> #
  end enterPop

  @: {best: 99999999999,
    pop: [ 1..$popSize -> [ $generateHalfChromosome, $generateHalfChromosome ] -> createCell ]};
  0 -> #

  <=1> $@.best !
  <>
    def babies: $@.pop -> mate;
    $babies... -> $.value -> !updateBest
'best $@.best;$#10;' -> !OUT::write
    @.pop: [$@.pop... -> ageAndMutate];
    $babies... -> !enterPop
    $isStagnated -> #
end geneSoup

// part 1
'The best path is $geneSoup@{popSize: 500, genes:$keys};
' -> !OUT::write
